{"ast":null,"code":"import baseSlice from './_baseSlice.js';\nimport isIterateeCall from './_isIterateeCall.js';\nimport toInteger from './toInteger.js';\n/* Built-in method references for those with the same name as other `lodash` methods. */\n\nvar nativeCeil = Math.ceil,\n    nativeMax = Math.max;\n/**\r\n * Creates an array of elements split into groups the length of `size`.\r\n * If `array` can't be split evenly, the final chunk will be the remaining\r\n * elements.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Array\r\n * @param {Array} array The array to process.\r\n * @param {number} [size=1] The length of each chunk\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n * @returns {Array} Returns the new array of chunks.\r\n * @example\r\n *\r\n * _.chunk(['a', 'b', 'c', 'd'], 2);\r\n * // => [['a', 'b'], ['c', 'd']]\r\n *\r\n * _.chunk(['a', 'b', 'c', 'd'], 3);\r\n * // => [['a', 'b', 'c'], ['d']]\r\n */\n\nfunction chunk(array, size, guard) {\n  if (guard ? isIterateeCall(array, size, guard) : size === undefined) {\n    size = 1;\n  } else {\n    size = nativeMax(toInteger(size), 0);\n  }\n\n  var length = array == null ? 0 : array.length;\n\n  if (!length || size < 1) {\n    return [];\n  }\n\n  var index = 0,\n      resIndex = 0,\n      result = Array(nativeCeil(length / size));\n\n  while (index < length) {\n    result[resIndex++] = baseSlice(array, index, index += size);\n  }\n\n  return result;\n}\n\nexport default chunk;","map":null,"metadata":{},"sourceType":"module"}