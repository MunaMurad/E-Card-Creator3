{"ast":null,"code":";\n\n(function (root, factory, undef) {\n  if (typeof exports === \"object\") {\n    // CommonJS\n    module.exports = exports = factory(require(\"./core\"), require(\"./sha1\"), require(\"./hmac\"));\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([\"./core\", \"./sha1\", \"./hmac\"], factory);\n  } else {\n    // Global (browser)\n    factory(root.CryptoJS);\n  }\n})(this, function (CryptoJS) {\n  (function () {\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var Base = C_lib.Base;\n    var WordArray = C_lib.WordArray;\n    var C_algo = C.algo;\n    var SHA1 = C_algo.SHA1;\n    var HMAC = C_algo.HMAC;\n    /**\r\n     * Password-Based Key Derivation Function 2 algorithm.\r\n     */\n\n    var PBKDF2 = C_algo.PBKDF2 = Base.extend({\n      /**\r\n       * Configuration options.\r\n       *\r\n       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\r\n       * @property {Hasher} hasher The hasher to use. Default: SHA1\r\n       * @property {number} iterations The number of iterations to perform. Default: 1\r\n       */\n      cfg: Base.extend({\n        keySize: 128 / 32,\n        hasher: SHA1,\n        iterations: 1\n      }),\n\n      /**\r\n       * Initializes a newly created key derivation function.\r\n       *\r\n       * @param {Object} cfg (Optional) The configuration options to use for the derivation.\r\n       *\r\n       * @example\r\n       *\r\n       *     var kdf = CryptoJS.algo.PBKDF2.create();\r\n       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });\r\n       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });\r\n       */\n      init: function (cfg) {\n        this.cfg = this.cfg.extend(cfg);\n      },\n\n      /**\r\n       * Computes the Password-Based Key Derivation Function 2.\r\n       *\r\n       * @param {WordArray|string} password The password.\r\n       * @param {WordArray|string} salt A salt.\r\n       *\r\n       * @return {WordArray} The derived key.\r\n       *\r\n       * @example\r\n       *\r\n       *     var key = kdf.compute(password, salt);\r\n       */\n      compute: function (password, salt) {\n        // Shortcut\n        var cfg = this.cfg; // Init HMAC\n\n        var hmac = HMAC.create(cfg.hasher, password); // Initial values\n\n        var derivedKey = WordArray.create();\n        var blockIndex = WordArray.create([0x00000001]); // Shortcuts\n\n        var derivedKeyWords = derivedKey.words;\n        var blockIndexWords = blockIndex.words;\n        var keySize = cfg.keySize;\n        var iterations = cfg.iterations; // Generate key\n\n        while (derivedKeyWords.length < keySize) {\n          var block = hmac.update(salt).finalize(blockIndex);\n          hmac.reset(); // Shortcuts\n\n          var blockWords = block.words;\n          var blockWordsLength = blockWords.length; // Iterations\n\n          var intermediate = block;\n\n          for (var i = 1; i < iterations; i++) {\n            intermediate = hmac.finalize(intermediate);\n            hmac.reset(); // Shortcut\n\n            var intermediateWords = intermediate.words; // XOR intermediate with block\n\n            for (var j = 0; j < blockWordsLength; j++) {\n              blockWords[j] ^= intermediateWords[j];\n            }\n          }\n\n          derivedKey.concat(block);\n          blockIndexWords[0]++;\n        }\n\n        derivedKey.sigBytes = keySize * 4;\n        return derivedKey;\n      }\n    });\n    /**\r\n     * Computes the Password-Based Key Derivation Function 2.\r\n     *\r\n     * @param {WordArray|string} password The password.\r\n     * @param {WordArray|string} salt A salt.\r\n     * @param {Object} cfg (Optional) The configuration options to use for this computation.\r\n     *\r\n     * @return {WordArray} The derived key.\r\n     *\r\n     * @static\r\n     *\r\n     * @example\r\n     *\r\n     *     var key = CryptoJS.PBKDF2(password, salt);\r\n     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });\r\n     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });\r\n     */\n\n    C.PBKDF2 = function (password, salt, cfg) {\n      return PBKDF2.create(cfg).compute(password, salt);\n    };\n  })();\n\n  return CryptoJS.PBKDF2;\n});","map":null,"metadata":{},"sourceType":"script"}