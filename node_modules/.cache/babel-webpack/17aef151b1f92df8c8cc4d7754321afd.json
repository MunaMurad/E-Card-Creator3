{"ast":null,"code":"import { fromCollectionRef } from '../observable/fromRef';\nimport { map, scan } from 'rxjs/operators';\nexport function docChanges(query, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(map(action => action.payload.docChanges().map(change => ({\n    type: change.type,\n    payload: change\n  }))));\n}\nexport function sortedChanges(query, events, scheduler) {\n  return fromCollectionRef(query, scheduler).pipe(map(changes => changes.payload.docChanges()), scan((current, changes) => combineChanges(current, changes, events), []), map(changes => changes.map(c => ({\n    type: c.type,\n    payload: c\n  }))));\n}\nexport function combineChanges(current, changes, events) {\n  changes.forEach(change => {\n    if (events.indexOf(change.type) > -1) {\n      current = combineChange(current, change);\n    }\n  });\n  return current;\n}\nexport function combineChange(combined, change) {\n  switch (change.type) {\n    case 'added':\n      if (combined[change.newIndex] && combined[change.newIndex].doc.ref.isEqual(change.doc.ref)) {} else {\n        combined.splice(change.newIndex, 0, change);\n      }\n\n      break;\n\n    case 'modified':\n      if (combined[change.oldIndex] == null || combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        if (change.oldIndex !== change.newIndex) {\n          combined.splice(change.oldIndex, 1);\n          combined.splice(change.newIndex, 0, change);\n        } else {\n          combined.splice(change.newIndex, 1, change);\n        }\n      }\n\n      break;\n\n    case 'removed':\n      if (combined[change.oldIndex] && combined[change.oldIndex].doc.ref.isEqual(change.doc.ref)) {\n        combined.splice(change.oldIndex, 1);\n      }\n\n      break;\n  }\n\n  return combined;\n} //# sourceMappingURL=changes.js.map","map":null,"metadata":{},"sourceType":"module"}