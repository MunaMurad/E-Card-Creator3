{"ast":null,"code":"export { c as createAnimation } from './animation-096c6391.js';\nexport { iosTransitionAnimation } from './ios.transition-12db6216.js';\nexport { mdTransitionAnimation } from './md.transition-eecd3a67.js';\nexport { g as getTimeGivenProgression } from './cubic-bezier-eea9a7a9.js';\nexport { createGesture } from './index-34cb2743.js';\nexport { g as getPlatforms, i as initialize, a as isPlatform } from './ionic-global-63a97a32.js';\nimport { a as addEventListener, r as raf, b as removeEventListener } from './helpers-dd7e4b7b.js';\nexport { c as componentOnReady } from './helpers-dd7e4b7b.js';\nexport { I as IonicSafeString } from './index-9e3fe806.js';\nexport { a as LIFECYCLE_DID_ENTER, c as LIFECYCLE_DID_LEAVE, L as LIFECYCLE_WILL_ENTER, b as LIFECYCLE_WILL_LEAVE, d as LIFECYCLE_WILL_UNLOAD } from './index-931440b1.js';\nexport { m as menuController } from './index-0d58a5bf.js';\nexport { b as actionSheetController, a as alertController, l as loadingController, m as modalController, p as pickerController, c as popoverController, t as toastController } from './overlays-e9ccff30.js';\nimport './gesture-controller-31cb6bb9.js';\nimport './index-7a8b7a1c.js';\nimport './hardware-back-button-4a6b37fb.js';\n\nconst setupConfig = config => {\n  const win = window;\n  const Ionic = win.Ionic;\n\n  if (Ionic && Ionic.config && Ionic.config.constructor.name !== 'Object') {\n    return;\n  }\n\n  win.Ionic = win.Ionic || {};\n  win.Ionic.config = Object.assign(Object.assign({}, win.Ionic.config), config);\n  return win.Ionic.config;\n};\n\nconst getMode = () => {\n  const win = window;\n  const config = win && win.Ionic && win.Ionic.config;\n\n  if (config) {\n    if (config.mode) {\n      return config.mode;\n    } else {\n      return config.get('mode');\n    }\n  }\n\n  return 'md';\n};\n/**\r\n * This is a plugin for Swiper that allows it to work\r\n * with Ionic Framework and the routing integrations.\r\n * Without this plugin, Swiper would be incapable of correctly\r\n * determining the dimensions of the slides component as\r\n * each view is initially hidden before transitioning in.\r\n */\n\n\nconst setupSwiperInIonic = (swiper, watchForIonPageChanges = true) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  const swiperEl = swiper.el;\n  const ionPage = swiperEl.closest('.ion-page');\n\n  if (!ionPage) {\n    if (watchForIonPageChanges) {\n      /**\r\n       * If no ion page found, it is possible\r\n       * that we are in the overlay setup step\r\n       * where the inner component has been\r\n       * created but not attached to the DOM yet.\r\n       * If so, wait for the .ion-page class to\r\n       * appear on the root div and re-run setup.\r\n       */\n      const rootNode = swiperEl.getRootNode();\n\n      if (rootNode.tagName === 'DIV') {\n        const mo = new MutationObserver(m => {\n          const mutation = m[0];\n          const wasEmpty = mutation.oldValue === null;\n          const hasIonPage = rootNode.classList.contains('ion-page');\n          /**\r\n           * Now that we have an .ion-page class\r\n           * we can safely attempt setup again.\r\n           */\n\n          if (wasEmpty && hasIonPage) {\n            mo.disconnect();\n            /**\r\n             * Set false here so we do not\r\n             * get infinite loops\r\n             */\n\n            setupSwiperInIonic(swiper, false);\n          }\n        });\n        mo.observe(rootNode, {\n          attributeFilter: ['class'],\n          attributeOldValue: true\n        });\n      }\n    }\n\n    return;\n  }\n  /**\r\n   * If using slides in a modal or\r\n   * popover we need to wait for the\r\n   * overlay to be shown as these components\r\n   * are hidden when they are initially created.\r\n   */\n\n\n  const modalOrPopover = swiperEl.closest('ion-modal, ion-popover');\n\n  if (modalOrPopover) {\n    const eventName = modalOrPopover.tagName === 'ION-MODAL' ? 'ionModalWillPresent' : 'ionPopoverWillPresent';\n\n    const overlayCallback = () => {\n      /**\r\n       * We need an raf here so the update\r\n       * is fired one tick after the overlay is shown.\r\n       */\n      raf(() => {\n        swiperEl.swiper.update();\n        removeEventListener(modalOrPopover, eventName, overlayCallback);\n      });\n    };\n\n    addEventListener(modalOrPopover, eventName, overlayCallback);\n  } else {\n    /**\r\n     * If using slides in a page\r\n     * we need to wait for the ion-page-invisible\r\n     * class to be removed so Swiper can correctly\r\n     * compute the dimensions of the slides.\r\n     */\n    const mo = new MutationObserver(m => {\n      var _a;\n\n      const mutation = m[0];\n      const wasPageHidden = (_a = mutation.oldValue) === null || _a === void 0 ? void 0 : _a.includes('ion-page-invisible');\n      const isPageHidden = ionPage.classList.contains('ion-page-invisible');\n      /**\r\n       * Only update Swiper if the page was\r\n       * hidden but is no longer hidden.\r\n       */\n\n      if (!isPageHidden && isPageHidden !== wasPageHidden) {\n        swiperEl.swiper.update();\n      }\n    });\n    mo.observe(ionPage, {\n      attributeFilter: ['class'],\n      attributeOldValue: true\n    });\n  }\n  /**\r\n   * We also need to listen for the appload event\r\n   * which is emitted by Stencil in the\r\n   * event that Swiper is being used on the\r\n   * view that is rendered initially.\r\n   */\n\n\n  const onAppLoad = () => {\n    swiperEl.swiper.update();\n    removeEventListener(window, 'appload', onAppLoad);\n  };\n\n  addEventListener(window, 'appload', onAppLoad);\n};\n\nconst IonicSwiper = {\n  name: 'ionic',\n  on: {\n    afterInit(swiper) {\n      setupSwiperInIonic(swiper);\n    }\n\n  }\n};\nexport { IonicSwiper, getMode, setupConfig };","map":null,"metadata":{},"sourceType":"module"}