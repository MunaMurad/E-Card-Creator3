{"ast":null,"code":"var Mode = require('./mode');\n\nvar NumericData = require('./numeric-data');\n\nvar AlphanumericData = require('./alphanumeric-data');\n\nvar ByteData = require('./byte-data');\n\nvar KanjiData = require('./kanji-data');\n\nvar Regex = require('./regex');\n\nvar Utils = require('./utils');\n\nvar dijkstra = require('dijkstrajs');\n/**\r\n * Returns UTF8 byte length\r\n *\r\n * @param  {String} str Input string\r\n * @return {Number}     Number of byte\r\n */\n\n\nfunction getStringByteLength(str) {\n  return unescape(encodeURIComponent(str)).length;\n}\n/**\r\n * Get a list of segments of the specified mode\r\n * from a string\r\n *\r\n * @param  {Mode}   mode Segment mode\r\n * @param  {String} str  String to process\r\n * @return {Array}       Array of object with segments data\r\n */\n\n\nfunction getSegments(regex, mode, str) {\n  var segments = [];\n  var result;\n\n  while ((result = regex.exec(str)) !== null) {\n    segments.push({\n      data: result[0],\n      index: result.index,\n      mode: mode,\n      length: result[0].length\n    });\n  }\n\n  return segments;\n}\n/**\r\n * Extracts a series of segments with the appropriate\r\n * modes from a string\r\n *\r\n * @param  {String} dataStr Input string\r\n * @return {Array}          Array of object with segments data\r\n */\n\n\nfunction getSegmentsFromString(dataStr) {\n  var numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);\n  var alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);\n  var byteSegs;\n  var kanjiSegs;\n\n  if (Utils.isKanjiModeEnabled()) {\n    byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);\n    kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);\n  } else {\n    byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);\n    kanjiSegs = [];\n  }\n\n  var segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);\n  return segs.sort(function (s1, s2) {\n    return s1.index - s2.index;\n  }).map(function (obj) {\n    return {\n      data: obj.data,\n      mode: obj.mode,\n      length: obj.length\n    };\n  });\n}\n/**\r\n * Returns how many bits are needed to encode a string of\r\n * specified length with the specified mode\r\n *\r\n * @param  {Number} length String length\r\n * @param  {Mode} mode     Segment mode\r\n * @return {Number}        Bit length\r\n */\n\n\nfunction getSegmentBitsLength(length, mode) {\n  switch (mode) {\n    case Mode.NUMERIC:\n      return NumericData.getBitsLength(length);\n\n    case Mode.ALPHANUMERIC:\n      return AlphanumericData.getBitsLength(length);\n\n    case Mode.KANJI:\n      return KanjiData.getBitsLength(length);\n\n    case Mode.BYTE:\n      return ByteData.getBitsLength(length);\n  }\n}\n/**\r\n * Merges adjacent segments which have the same mode\r\n *\r\n * @param  {Array} segs Array of object with segments data\r\n * @return {Array}      Array of object with segments data\r\n */\n\n\nfunction mergeSegments(segs) {\n  return segs.reduce(function (acc, curr) {\n    var prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;\n\n    if (prevSeg && prevSeg.mode === curr.mode) {\n      acc[acc.length - 1].data += curr.data;\n      return acc;\n    }\n\n    acc.push(curr);\n    return acc;\n  }, []);\n}\n/**\r\n * Generates a list of all possible nodes combination which\r\n * will be used to build a segments graph.\r\n *\r\n * Nodes are divided by groups. Each group will contain a list of all the modes\r\n * in which is possible to encode the given text.\r\n *\r\n * For example the text '12345' can be encoded as Numeric, Alphanumeric or Byte.\r\n * The group for '12345' will contain then 3 objects, one for each\r\n * possible encoding mode.\r\n *\r\n * Each node represents a possible segment.\r\n *\r\n * @param  {Array} segs Array of object with segments data\r\n * @return {Array}      Array of object with segments data\r\n */\n\n\nfunction buildNodes(segs) {\n  var nodes = [];\n\n  for (var i = 0; i < segs.length; i++) {\n    var seg = segs[i];\n\n    switch (seg.mode) {\n      case Mode.NUMERIC:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.ALPHANUMERIC,\n          length: seg.length\n        }, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: seg.length\n        }]);\n        break;\n\n      case Mode.ALPHANUMERIC:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: seg.length\n        }]);\n        break;\n\n      case Mode.KANJI:\n        nodes.push([seg, {\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: getStringByteLength(seg.data)\n        }]);\n        break;\n\n      case Mode.BYTE:\n        nodes.push([{\n          data: seg.data,\n          mode: Mode.BYTE,\n          length: getStringByteLength(seg.data)\n        }]);\n    }\n  }\n\n  return nodes;\n}\n/**\r\n * Builds a graph from a list of nodes.\r\n * All segments in each node group will be connected with all the segments of\r\n * the next group and so on.\r\n *\r\n * At each connection will be assigned a weight depending on the\r\n * segment's byte length.\r\n *\r\n * @param  {Array} nodes    Array of object with segments data\r\n * @param  {Number} version QR Code version\r\n * @return {Object}         Graph of all possible segments\r\n */\n\n\nfunction buildGraph(nodes, version) {\n  var table = {};\n  var graph = {\n    'start': {}\n  };\n  var prevNodeIds = ['start'];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeGroup = nodes[i];\n    var currentNodeIds = [];\n\n    for (var j = 0; j < nodeGroup.length; j++) {\n      var node = nodeGroup[j];\n      var key = '' + i + j;\n      currentNodeIds.push(key);\n      table[key] = {\n        node: node,\n        lastCount: 0\n      };\n      graph[key] = {};\n\n      for (var n = 0; n < prevNodeIds.length; n++) {\n        var prevNodeId = prevNodeIds[n];\n\n        if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {\n          graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);\n          table[prevNodeId].lastCount += node.length;\n        } else {\n          if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;\n          graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version); // switch cost\n        }\n      }\n    }\n\n    prevNodeIds = currentNodeIds;\n  }\n\n  for (n = 0; n < prevNodeIds.length; n++) {\n    graph[prevNodeIds[n]]['end'] = 0;\n  }\n\n  return {\n    map: graph,\n    table: table\n  };\n}\n/**\r\n * Builds a segment from a specified data and mode.\r\n * If a mode is not specified, the more suitable will be used.\r\n *\r\n * @param  {String} data             Input data\r\n * @param  {Mode | String} modesHint Data mode\r\n * @return {Segment}                 Segment\r\n */\n\n\nfunction buildSingleSegment(data, modesHint) {\n  var mode;\n  var bestMode = Mode.getBestModeForData(data);\n  mode = Mode.from(modesHint, bestMode); // Make sure data can be encoded\n\n  if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {\n    throw new Error('\"' + data + '\"' + ' cannot be encoded with mode ' + Mode.toString(mode) + '.\\n Suggested mode is: ' + Mode.toString(bestMode));\n  } // Use Mode.BYTE if Kanji support is disabled\n\n\n  if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {\n    mode = Mode.BYTE;\n  }\n\n  switch (mode) {\n    case Mode.NUMERIC:\n      return new NumericData(data);\n\n    case Mode.ALPHANUMERIC:\n      return new AlphanumericData(data);\n\n    case Mode.KANJI:\n      return new KanjiData(data);\n\n    case Mode.BYTE:\n      return new ByteData(data);\n  }\n}\n/**\r\n * Builds a list of segments from an array.\r\n * Array can contain Strings or Objects with segment's info.\r\n *\r\n * For each item which is a string, will be generated a segment with the given\r\n * string and the more appropriate encoding mode.\r\n *\r\n * For each item which is an object, will be generated a segment with the given\r\n * data and mode.\r\n * Objects must contain at least the property \"data\".\r\n * If property \"mode\" is not present, the more suitable mode will be used.\r\n *\r\n * @param  {Array} array Array of objects with segments data\r\n * @return {Array}       Array of Segments\r\n */\n\n\nexports.fromArray = function fromArray(array) {\n  return array.reduce(function (acc, seg) {\n    if (typeof seg === 'string') {\n      acc.push(buildSingleSegment(seg, null));\n    } else if (seg.data) {\n      acc.push(buildSingleSegment(seg.data, seg.mode));\n    }\n\n    return acc;\n  }, []);\n};\n/**\r\n * Builds an optimized sequence of segments from a string,\r\n * which will produce the shortest possible bitstream.\r\n *\r\n * @param  {String} data    Input string\r\n * @param  {Number} version QR Code version\r\n * @return {Array}          Array of segments\r\n */\n\n\nexports.fromString = function fromString(data, version) {\n  var segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());\n  var nodes = buildNodes(segs);\n  var graph = buildGraph(nodes, version);\n  var path = dijkstra.find_path(graph.map, 'start', 'end');\n  var optimizedSegs = [];\n\n  for (var i = 1; i < path.length - 1; i++) {\n    optimizedSegs.push(graph.table[path[i]].node);\n  }\n\n  return exports.fromArray(mergeSegments(optimizedSegs));\n};\n/**\r\n * Splits a string in various segments with the modes which\r\n * best represent their content.\r\n * The produced segments are far from being optimized.\r\n * The output of this function is only used to estimate a QR Code version\r\n * which may contain the data.\r\n *\r\n * @param  {string} data Input string\r\n * @return {Array}       Array of segments\r\n */\n\n\nexports.rawSplit = function rawSplit(data) {\n  return exports.fromArray(getSegmentsFromString(data, Utils.isKanjiModeEnabled()));\n};","map":null,"metadata":{},"sourceType":"script"}