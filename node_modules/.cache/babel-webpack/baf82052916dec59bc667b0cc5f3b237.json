{"ast":null,"code":";\n\n(function (root, factory) {\n  if (typeof exports === \"object\") {\n    // CommonJS\n    module.exports = exports = factory();\n  } else if (typeof define === \"function\" && define.amd) {\n    // AMD\n    define([], factory);\n  } else {\n    // Global (browser)\n    root.CryptoJS = factory();\n  }\n})(this, function () {\n  /*globals window, global, require*/\n\n  /**\r\n   * CryptoJS core components.\r\n   */\n  var CryptoJS = CryptoJS || function (Math, undefined) {\n    var crypto; // Native crypto from window (Browser)\n\n    if (typeof window !== 'undefined' && window.crypto) {\n      crypto = window.crypto;\n    } // Native crypto in web worker (Browser)\n\n\n    if (typeof self !== 'undefined' && self.crypto) {\n      crypto = self.crypto;\n    } // Native crypto from worker\n\n\n    if (typeof globalThis !== 'undefined' && globalThis.crypto) {\n      crypto = globalThis.crypto;\n    } // Native (experimental IE 11) crypto from window (Browser)\n\n\n    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n      crypto = window.msCrypto;\n    } // Native crypto from global (NodeJS)\n\n\n    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n      crypto = global.crypto;\n    } // Native crypto import via require (NodeJS)\n\n\n    if (!crypto && typeof require === 'function') {\n      try {\n        crypto = require('crypto');\n      } catch (err) {}\n    }\n    /*\r\n     * Cryptographically secure pseudorandom number generator\r\n     *\r\n     * As Math.random() is cryptographically not safe to use\r\n     */\n\n\n    var cryptoSecureRandomInt = function () {\n      if (crypto) {\n        // Use getRandomValues method (Browser)\n        if (typeof crypto.getRandomValues === 'function') {\n          try {\n            return crypto.getRandomValues(new Uint32Array(1))[0];\n          } catch (err) {}\n        } // Use randomBytes method (NodeJS)\n\n\n        if (typeof crypto.randomBytes === 'function') {\n          try {\n            return crypto.randomBytes(4).readInt32LE();\n          } catch (err) {}\n        }\n      }\n\n      throw new Error('Native crypto module could not be used to get secure random number.');\n    };\n    /*\r\n     * Local polyfill of Object.create\r\n       */\n\n\n    var create = Object.create || function () {\n      function F() {}\n\n      return function (obj) {\n        var subtype;\n        F.prototype = obj;\n        subtype = new F();\n        F.prototype = null;\n        return subtype;\n      };\n    }();\n    /**\r\n     * CryptoJS namespace.\r\n     */\n\n\n    var C = {};\n    /**\r\n     * Library namespace.\r\n     */\n\n    var C_lib = C.lib = {};\n    /**\r\n     * Base object for prototypal inheritance.\r\n     */\n\n    var Base = C_lib.Base = function () {\n      return {\n        /**\r\n         * Creates a new object that inherits from this object.\r\n         *\r\n         * @param {Object} overrides Properties to copy into the new object.\r\n         *\r\n         * @return {Object} The new object.\r\n         *\r\n         * @static\r\n         *\r\n         * @example\r\n         *\r\n         *     var MyType = CryptoJS.lib.Base.extend({\r\n         *         field: 'value',\r\n         *\r\n         *         method: function () {\r\n         *         }\r\n         *     });\r\n         */\n        extend: function (overrides) {\n          // Spawn\n          var subtype = create(this); // Augment\n\n          if (overrides) {\n            subtype.mixIn(overrides);\n          } // Create default initializer\n\n\n          if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n            subtype.init = function () {\n              subtype.$super.init.apply(this, arguments);\n            };\n          } // Initializer's prototype is the subtype object\n\n\n          subtype.init.prototype = subtype; // Reference supertype\n\n          subtype.$super = this;\n          return subtype;\n        },\n\n        /**\r\n         * Extends this object and runs the init method.\r\n         * Arguments to create() will be passed to init().\r\n         *\r\n         * @return {Object} The new object.\r\n         *\r\n         * @static\r\n         *\r\n         * @example\r\n         *\r\n         *     var instance = MyType.create();\r\n         */\n        create: function () {\n          var instance = this.extend();\n          instance.init.apply(instance, arguments);\n          return instance;\n        },\n\n        /**\r\n         * Initializes a newly created object.\r\n         * Override this method to add some logic when your objects are created.\r\n         *\r\n         * @example\r\n         *\r\n         *     var MyType = CryptoJS.lib.Base.extend({\r\n         *         init: function () {\r\n         *             // ...\r\n         *         }\r\n         *     });\r\n         */\n        init: function () {},\n\n        /**\r\n         * Copies properties into this object.\r\n         *\r\n         * @param {Object} properties The properties to mix in.\r\n         *\r\n         * @example\r\n         *\r\n         *     MyType.mixIn({\r\n         *         field: 'value'\r\n         *     });\r\n         */\n        mixIn: function (properties) {\n          for (var propertyName in properties) {\n            if (properties.hasOwnProperty(propertyName)) {\n              this[propertyName] = properties[propertyName];\n            }\n          } // IE won't copy toString using the loop above\n\n\n          if (properties.hasOwnProperty('toString')) {\n            this.toString = properties.toString;\n          }\n        },\n\n        /**\r\n         * Creates a copy of this object.\r\n         *\r\n         * @return {Object} The clone.\r\n         *\r\n         * @example\r\n         *\r\n         *     var clone = instance.clone();\r\n         */\n        clone: function () {\n          return this.init.prototype.extend(this);\n        }\n      };\n    }();\n    /**\r\n     * An array of 32-bit words.\r\n     *\r\n     * @property {Array} words The array of 32-bit words.\r\n     * @property {number} sigBytes The number of significant bytes in this word array.\r\n     */\n\n\n    var WordArray = C_lib.WordArray = Base.extend({\n      /**\r\n       * Initializes a newly created word array.\r\n       *\r\n       * @param {Array} words (Optional) An array of 32-bit words.\r\n       * @param {number} sigBytes (Optional) The number of significant bytes in the words.\r\n       *\r\n       * @example\r\n       *\r\n       *     var wordArray = CryptoJS.lib.WordArray.create();\r\n       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\r\n       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\r\n       */\n      init: function (words, sigBytes) {\n        words = this.words = words || [];\n\n        if (sigBytes != undefined) {\n          this.sigBytes = sigBytes;\n        } else {\n          this.sigBytes = words.length * 4;\n        }\n      },\n\n      /**\r\n       * Converts this word array to a string.\r\n       *\r\n       * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\r\n       *\r\n       * @return {string} The stringified word array.\r\n       *\r\n       * @example\r\n       *\r\n       *     var string = wordArray + '';\r\n       *     var string = wordArray.toString();\r\n       *     var string = wordArray.toString(CryptoJS.enc.Utf8);\r\n       */\n      toString: function (encoder) {\n        return (encoder || Hex).stringify(this);\n      },\n\n      /**\r\n       * Concatenates a word array to this word array.\r\n       *\r\n       * @param {WordArray} wordArray The word array to append.\r\n       *\r\n       * @return {WordArray} This word array.\r\n       *\r\n       * @example\r\n       *\r\n       *     wordArray1.concat(wordArray2);\r\n       */\n      concat: function (wordArray) {\n        // Shortcuts\n        var thisWords = this.words;\n        var thatWords = wordArray.words;\n        var thisSigBytes = this.sigBytes;\n        var thatSigBytes = wordArray.sigBytes; // Clamp excess bits\n\n        this.clamp(); // Concat\n\n        if (thisSigBytes % 4) {\n          // Copy one byte at a time\n          for (var i = 0; i < thatSigBytes; i++) {\n            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;\n          }\n        } else {\n          // Copy one word at a time\n          for (var j = 0; j < thatSigBytes; j += 4) {\n            thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];\n          }\n        }\n\n        this.sigBytes += thatSigBytes; // Chainable\n\n        return this;\n      },\n\n      /**\r\n       * Removes insignificant bits.\r\n       *\r\n       * @example\r\n       *\r\n       *     wordArray.clamp();\r\n       */\n      clamp: function () {\n        // Shortcuts\n        var words = this.words;\n        var sigBytes = this.sigBytes; // Clamp\n\n        words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;\n        words.length = Math.ceil(sigBytes / 4);\n      },\n\n      /**\r\n       * Creates a copy of this word array.\r\n       *\r\n       * @return {WordArray} The clone.\r\n       *\r\n       * @example\r\n       *\r\n       *     var clone = wordArray.clone();\r\n       */\n      clone: function () {\n        var clone = Base.clone.call(this);\n        clone.words = this.words.slice(0);\n        return clone;\n      },\n\n      /**\r\n       * Creates a word array filled with random bytes.\r\n       *\r\n       * @param {number} nBytes The number of random bytes to generate.\r\n       *\r\n       * @return {WordArray} The random word array.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var wordArray = CryptoJS.lib.WordArray.random(16);\r\n       */\n      random: function (nBytes) {\n        var words = [];\n\n        for (var i = 0; i < nBytes; i += 4) {\n          words.push(cryptoSecureRandomInt());\n        }\n\n        return new WordArray.init(words, nBytes);\n      }\n    });\n    /**\r\n     * Encoder namespace.\r\n     */\n\n    var C_enc = C.enc = {};\n    /**\r\n     * Hex encoding strategy.\r\n     */\n\n    var Hex = C_enc.Hex = {\n      /**\r\n       * Converts a word array to a hex string.\r\n       *\r\n       * @param {WordArray} wordArray The word array.\r\n       *\r\n       * @return {string} The hex string.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\r\n       */\n      stringify: function (wordArray) {\n        // Shortcuts\n        var words = wordArray.words;\n        var sigBytes = wordArray.sigBytes; // Convert\n\n        var hexChars = [];\n\n        for (var i = 0; i < sigBytes; i++) {\n          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n          hexChars.push((bite >>> 4).toString(16));\n          hexChars.push((bite & 0x0f).toString(16));\n        }\n\n        return hexChars.join('');\n      },\n\n      /**\r\n       * Converts a hex string to a word array.\r\n       *\r\n       * @param {string} hexStr The hex string.\r\n       *\r\n       * @return {WordArray} The word array.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\r\n       */\n      parse: function (hexStr) {\n        // Shortcut\n        var hexStrLength = hexStr.length; // Convert\n\n        var words = [];\n\n        for (var i = 0; i < hexStrLength; i += 2) {\n          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;\n        }\n\n        return new WordArray.init(words, hexStrLength / 2);\n      }\n    };\n    /**\r\n     * Latin1 encoding strategy.\r\n     */\n\n    var Latin1 = C_enc.Latin1 = {\n      /**\r\n       * Converts a word array to a Latin1 string.\r\n       *\r\n       * @param {WordArray} wordArray The word array.\r\n       *\r\n       * @return {string} The Latin1 string.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\r\n       */\n      stringify: function (wordArray) {\n        // Shortcuts\n        var words = wordArray.words;\n        var sigBytes = wordArray.sigBytes; // Convert\n\n        var latin1Chars = [];\n\n        for (var i = 0; i < sigBytes; i++) {\n          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;\n          latin1Chars.push(String.fromCharCode(bite));\n        }\n\n        return latin1Chars.join('');\n      },\n\n      /**\r\n       * Converts a Latin1 string to a word array.\r\n       *\r\n       * @param {string} latin1Str The Latin1 string.\r\n       *\r\n       * @return {WordArray} The word array.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\r\n       */\n      parse: function (latin1Str) {\n        // Shortcut\n        var latin1StrLength = latin1Str.length; // Convert\n\n        var words = [];\n\n        for (var i = 0; i < latin1StrLength; i++) {\n          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;\n        }\n\n        return new WordArray.init(words, latin1StrLength);\n      }\n    };\n    /**\r\n     * UTF-8 encoding strategy.\r\n     */\n\n    var Utf8 = C_enc.Utf8 = {\n      /**\r\n       * Converts a word array to a UTF-8 string.\r\n       *\r\n       * @param {WordArray} wordArray The word array.\r\n       *\r\n       * @return {string} The UTF-8 string.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\r\n       */\n      stringify: function (wordArray) {\n        try {\n          return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n        } catch (e) {\n          throw new Error('Malformed UTF-8 data');\n        }\n      },\n\n      /**\r\n       * Converts a UTF-8 string to a word array.\r\n       *\r\n       * @param {string} utf8Str The UTF-8 string.\r\n       *\r\n       * @return {WordArray} The word array.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\r\n       */\n      parse: function (utf8Str) {\n        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n      }\n    };\n    /**\r\n     * Abstract buffered block algorithm template.\r\n     *\r\n     * The property blockSize must be implemented in a concrete subtype.\r\n     *\r\n     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\r\n     */\n\n    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n      /**\r\n       * Resets this block algorithm's data buffer to its initial state.\r\n       *\r\n       * @example\r\n       *\r\n       *     bufferedBlockAlgorithm.reset();\r\n       */\n      reset: function () {\n        // Initial values\n        this._data = new WordArray.init();\n        this._nDataBytes = 0;\n      },\n\n      /**\r\n       * Adds new data to this block algorithm's buffer.\r\n       *\r\n       * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\r\n       *\r\n       * @example\r\n       *\r\n       *     bufferedBlockAlgorithm._append('data');\r\n       *     bufferedBlockAlgorithm._append(wordArray);\r\n       */\n      _append: function (data) {\n        // Convert string to WordArray, else assume WordArray already\n        if (typeof data == 'string') {\n          data = Utf8.parse(data);\n        } // Append\n\n\n        this._data.concat(data);\n\n        this._nDataBytes += data.sigBytes;\n      },\n\n      /**\r\n       * Processes available data blocks.\r\n       *\r\n       * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\r\n       *\r\n       * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\r\n       *\r\n       * @return {WordArray} The processed data.\r\n       *\r\n       * @example\r\n       *\r\n       *     var processedData = bufferedBlockAlgorithm._process();\r\n       *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\r\n       */\n      _process: function (doFlush) {\n        var processedWords; // Shortcuts\n\n        var data = this._data;\n        var dataWords = data.words;\n        var dataSigBytes = data.sigBytes;\n        var blockSize = this.blockSize;\n        var blockSizeBytes = blockSize * 4; // Count blocks ready\n\n        var nBlocksReady = dataSigBytes / blockSizeBytes;\n\n        if (doFlush) {\n          // Round up to include partial blocks\n          nBlocksReady = Math.ceil(nBlocksReady);\n        } else {\n          // Round down to include only full blocks,\n          // less the number of blocks that must remain in the buffer\n          nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n        } // Count words ready\n\n\n        var nWordsReady = nBlocksReady * blockSize; // Count bytes ready\n\n        var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); // Process blocks\n\n        if (nWordsReady) {\n          for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n            // Perform concrete-algorithm logic\n            this._doProcessBlock(dataWords, offset);\n          } // Remove processed words\n\n\n          processedWords = dataWords.splice(0, nWordsReady);\n          data.sigBytes -= nBytesReady;\n        } // Return processed words\n\n\n        return new WordArray.init(processedWords, nBytesReady);\n      },\n\n      /**\r\n       * Creates a copy of this object.\r\n       *\r\n       * @return {Object} The clone.\r\n       *\r\n       * @example\r\n       *\r\n       *     var clone = bufferedBlockAlgorithm.clone();\r\n       */\n      clone: function () {\n        var clone = Base.clone.call(this);\n        clone._data = this._data.clone();\n        return clone;\n      },\n      _minBufferSize: 0\n    });\n    /**\r\n     * Abstract hasher template.\r\n     *\r\n     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\r\n     */\n\n    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n      /**\r\n       * Configuration options.\r\n       */\n      cfg: Base.extend(),\n\n      /**\r\n       * Initializes a newly created hasher.\r\n       *\r\n       * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\r\n       *\r\n       * @example\r\n       *\r\n       *     var hasher = CryptoJS.algo.SHA256.create();\r\n       */\n      init: function (cfg) {\n        // Apply config defaults\n        this.cfg = this.cfg.extend(cfg); // Set initial values\n\n        this.reset();\n      },\n\n      /**\r\n       * Resets this hasher to its initial state.\r\n       *\r\n       * @example\r\n       *\r\n       *     hasher.reset();\r\n       */\n      reset: function () {\n        // Reset data buffer\n        BufferedBlockAlgorithm.reset.call(this); // Perform concrete-hasher logic\n\n        this._doReset();\n      },\n\n      /**\r\n       * Updates this hasher with a message.\r\n       *\r\n       * @param {WordArray|string} messageUpdate The message to append.\r\n       *\r\n       * @return {Hasher} This hasher.\r\n       *\r\n       * @example\r\n       *\r\n       *     hasher.update('message');\r\n       *     hasher.update(wordArray);\r\n       */\n      update: function (messageUpdate) {\n        // Append\n        this._append(messageUpdate); // Update the hash\n\n\n        this._process(); // Chainable\n\n\n        return this;\n      },\n\n      /**\r\n       * Finalizes the hash computation.\r\n       * Note that the finalize operation is effectively a destructive, read-once operation.\r\n       *\r\n       * @param {WordArray|string} messageUpdate (Optional) A final message update.\r\n       *\r\n       * @return {WordArray} The hash.\r\n       *\r\n       * @example\r\n       *\r\n       *     var hash = hasher.finalize();\r\n       *     var hash = hasher.finalize('message');\r\n       *     var hash = hasher.finalize(wordArray);\r\n       */\n      finalize: function (messageUpdate) {\n        // Final message update\n        if (messageUpdate) {\n          this._append(messageUpdate);\n        } // Perform concrete-hasher logic\n\n\n        var hash = this._doFinalize();\n\n        return hash;\n      },\n      blockSize: 512 / 32,\n\n      /**\r\n       * Creates a shortcut function to a hasher's object interface.\r\n       *\r\n       * @param {Hasher} hasher The hasher to create a helper for.\r\n       *\r\n       * @return {Function} The shortcut function.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\r\n       */\n      _createHelper: function (hasher) {\n        return function (message, cfg) {\n          return new hasher.init(cfg).finalize(message);\n        };\n      },\n\n      /**\r\n       * Creates a shortcut function to the HMAC's object interface.\r\n       *\r\n       * @param {Hasher} hasher The hasher to use in this HMAC helper.\r\n       *\r\n       * @return {Function} The shortcut function.\r\n       *\r\n       * @static\r\n       *\r\n       * @example\r\n       *\r\n       *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\r\n       */\n      _createHmacHelper: function (hasher) {\n        return function (message, key) {\n          return new C_algo.HMAC.init(hasher, key).finalize(message);\n        };\n      }\n    });\n    /**\r\n     * Algorithm namespace.\r\n     */\n\n    var C_algo = C.algo = {};\n    return C;\n  }(Math);\n\n  return CryptoJS;\n});","map":null,"metadata":{},"sourceType":"script"}